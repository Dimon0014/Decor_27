# coding=utf-8
def method_friendly_decorator(method_to_decorate):
    def wrapper(self, lie):
        lie = lie - 3  # действительно, дружелюбно - снизим возраст ещё сильней :-)
        return method_to_decorate(self, lie)

    return wrapper                                   # в начале объявляем декоратор, затем класс внутри класса
                                                     #  создаем функцию и декорируем ее.
                                                     # в принципе логика обратная есть класс с функцией внутри
class Lucy(object):                                  # сверху доптсывается(объявляется) декоратор и
    def __init__(self):                             # добавляется строкой с @(собакой) и названием к функции
        self.age = 32                               # которой хотим добавить дополнительный функционал
                                                    # причем в декораторе добавляем аргументы как в дек.функции
                                                    # Получается что мы их пробрассываем, в начале они задествованны
    @method_friendly_decorator                      # или незадествованны в декораторе, а затем попадают в дек.функцию
    def sayYourAge(self, lie):
        print "Мне %s, а ты бы сколько дал?" % (self.age + lie) # через знак процента вычисляются данные в скобках
                                                                # а затем через переменную %s добавляются в строку

l = Lucy()        # создаем объект типа Lucy
l.sayYourAge(-3)  # вызываем метод(декорированный)
# выведет: Мне 26, а ты бы сколько дал?